1. Dadas dos listas simples enlazadas ya creadas cuyos inicios son PTR1 y PTR2, hacer un algoritmo que elimine de la lista PTR1 los elementos en común entre las dos listas. Nota: No se puede asumir que las listas están ordenadas.

def eliminar_elementos_comunes(PTR1, PTR2):
    nodo1 = PTR1
    while nodo1 is not None:
        nodo2 = PTR2
        while nodo2 is not None:
            if nodo1.informacion == nodo2.informacion:
                if nodo1 == PTR1:
                    PTR1 = nodo1.siguiente
                else:
                    nodo1.anterior.siguiente = nodo1.siguiente
                if nodo1.siguiente is not None:
                    nodo1.siguiente.anterior = nodo1.anterior
            nodo2 = nodo2.siguiente
        nodo1 = nodo1.siguiente
    return PTR1



2. Hacer un algoritmo que escriba el número total de elementos diferentes en una lista enlazada ya creada. ¿Cuáles son?

class Nodo:
    def __init__(self, valor, siguiente=None):
        self.valor = valor
        self.siguiente = siguiente

# Creamos una lista enlazada de ejemplo
nodo4 = Nodo(2)
nodo3 = Nodo(3, nodo4)
nodo2 = Nodo(1, nodo3)
nodo1 = Nodo(2, nodo2)
nodo0 = Nodo(1, nodo1)
lista = nodo0

# Contamos los elementos diferentes en la lista
cantidad = contar_elementos_diferentes(lista)

# Imprimimos la cantidad de elementos diferentes
print(f"Hay {cantidad} elementos diferentes en la lista.")





3. Hacer un algoritmo que dada una lista simple enlazada ya creada, invierta su sentido. (no puede cambiar la información, solo los enlaces).

class Nodo:
    def __init__(self, valor, siguiente=None):
        self.valor = valor
        self.siguiente = siguiente

def invertir_lista(lista):
    actual = lista
    siguiente = None
    previo = None

    while actual:
        siguiente = actual.siguiente
        actual.siguiente = previo
        previo = actual
        actual = siguiente

    return previo

class Nodo:
    def __init__(self, valor, siguiente=None):
        self.valor = valor
        self.siguiente = siguiente

# Creamos una lista enlazada de ejemplo
nodo4 = Nodo(4)
nodo3 = Nodo(3, nodo4)
nodo2 = Nodo(2, nodo3)
nodo1 = Nodo(1, nodo2)
nodo0 = Nodo(0, nodo1)
lista_original = nodo0

# Invertimos la lista original
lista_invertida = invertir_lista(lista_original)

# Imprimimos los valores de la lista original y la lista invertida
actual = lista_original
while actual:
    print(actual.valor, end=" ")
    actual = actual.siguiente
print()
actual = lista_invertida
while actual:
    print(actual.valor, end=" ")
    actual = actual.siguiente




4. Hacer un algoritmo que realice las siguientes operaciones a medida que recorre una lista:

a. Si la información del nodo es negativa insertar un nuevo nodo antes de este con información igual a -1000

b. Si la información del nodo es positiva insertar un nuevo nodo después de este con información igual a 1000

c. Si la información del nodo es cero eliminarlo.

No se permite recorrer la lista más de una vez.


class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def modify_list(head):
    # Variable to keep track of previous node
    prev = None
    # Variable to keep track of current node
    current = head
    while current is not None:
        # Check if the node's data is negative
        if current.data < 0:
            # Create a new node with data = -1000
            new_node = Node(-1000)
            # Set the new node's next pointer to the current node
            new_node.next = current
            # Set the previous node's next pointer to the new node
            if prev is not None:
                prev.next = new_node
            else:
                # If the current node is the head node, update the head node to the new node
                head = new_node
            # Update the current node to the new node
            current = new_node
        # Check if the node's data is positive
        elif current.data > 0:
            # Create a new node with data = 1000
            new_node = Node(1000)
            # Set the new node's next pointer to the current node's next node
            new_node.next = current.next
            # Set the current node's next pointer to the new node
            current.next = new_node
            # Update the current node to the next node
            current = new_node.next
        else:
            # If the node's data is 0, delete the node
            if prev is not None:
                # Update the previous node's next pointer to the current node's next node
                prev.next = current.next
            else:
                # If the current node is the head node, update the head node to the next node
                head = current.next
            # Update the current node to the next node
            current = current.next
    return head
    
    
    class Nodo:
    def __init__(self, valor, siguiente=None):
        self.valor = valor
        self.siguiente = siguiente

# Creamos una lista enlazada de ejemplo
nodo4 = Nodo(4)
nodo3 = Nodo(3, nodo4)
nodo2 = Nodo(2, nodo3)
nodo1 = Nodo(1, nodo2)
nodo0 = Nodo(0, nodo1)
lista_original = nodo0

# Modificamos la lista original
lista_modificada = modificar_lista(lista_original)

# Imprimimos los valores de la lista original y la lista modificada
actual = lista_original
while actual:
    print(actual.valor, end=" ")
    actual = actual.siguiente
print()
actual = lista_modificada
while actual:
    print(actual.valor, end=" ")
    actual = actual.siguiente

    
    
 5. Hacer un algoritmo que recorra una lista y regrese dos listas L1 y L2. L1 debe contener los elementos de la lista inicial (sin repetir) y L2 debe contener las veces que se repite ese número.
    
    
    def contar_elementos(lista):
    # creamos un diccionario para contar las ocurrencias de cada elemento
    diccionario = {}
    for elemento in lista:
        if elemento in diccionario:
            diccionario[elemento] += 1
        else:
            diccionario[elemento] = 1
    
    # creamos las listas L1 y L2 a partir del diccionario
    L1 = list(diccionario.keys())
    L2 = list(diccionario.values())
    
    return L1, L2


  lista_original = [1, 2, 3, 2, 1, 1, 4]
  L1, L2 = contar_elementos(lista_original)

 print("L1:", L1)
 print("L2:", L2)
